/**
 * @author 小岳  2019/7/7
 *		 线程的三种实现方式
 * 		1.第一种继承Thrad类创建线程
 * 		2.第二种实现Runnable接口创建线程。
 * 		3.第三种实现Callable接口和Futrue接口创建线程,call方法有返回值
 *			线程生命周期：new,Ready,Running,block
 *			线程阻塞和运行，sleep,wait,试图获取线程同步器监视器，suspend挂起。io阻塞
 *			线程的死亡：isAlive();true线程处于就绪（Ready）运行(Running)，阻塞(Block)，false:死亡(Dead)和新建状态（new）
 * 			线程的控制：join（），一个线程调用此方法时，此线程将优先执行，结束后其他线程才继续执行。
 * 			后台线程：setDaemin()将线程设置成后台线程，所有的前台线程都死亡，后台线程会自动死亡。
 * 			线程的睡眠 ：sleep()
 *
 */


/**
 * @author 小岳  2019/7/7
 * 
 * 			线程的休眠：sleep：线程休眠处于暂停状态，阻塞线程，不会获得执行机会，将会执行其他处于就绪状态的线程。
 * 					  yield： 线程暂停，线程不会阻塞，时间很短，将会执行优先级与此线程相同或比他高的并处于就绪状态的线程。
 * 
 * 			线程的优先级：setPriority(1至10),，有三个默认的优先级常量1，5，10，优先级高的执行机会多些。
 * 
 * 			线程的同步：多个线程在访问同一资源时候“偶然”出现的线程安全问题，（数据不准确），
 * 					  java提供了同步监视器解决线程安全问题。
 * 					  同步代码块：synchronized(obj){	}//此时当一条线程获得次同步监视器对象锁，其他线程将无法进入此代码块。
 * 					  同步方法：public synchronized void draw(double drawBalance) 多条线程调用此方法时，只能有一条线程获得对Acount1对象的锁定。
 *			释放同步监视器的锁定：break,return,wait(),Exeception,error,
 *							不会释放：sleep(),yield(),suspend(),resume().
 *			同步锁(Lock):private final ReentrantLock lock = new ReentrantLock();//可重入锁
 * 							lock.lock();//锁定同步监视
 * 								执行操作。。。。
 * 							lock.unlock();//释放同步监视器锁定
 
 *
 */

/**
 * @author 小岳 2019/7/7
 * 		死锁：多条线程互相等待对方释放同步监视器锁时就会发生死锁。
 * 			A线程获得了a对象同步监视器进行锁定，此时出现阻塞状态，B线程获得b对象同步监视器进行锁定。A线程恢复想要获得b对象同步监视器锁，
 * 				结果B线程已经在A线程处于阻塞状态时将b对象锁定了。所以A线程此时就将处于等待状态，等待B线程释放b，同理，B线程也是执行相同操作。
 * 					A线程要获得B线程已经锁定的资源，B对象要获得A线程已经锁定的资源。A，B两线程都处于等待状态。于是就造成了死锁。	
 *			解决死锁：避免一条线程对多个同步监视器进行锁定。
 * 				应保证多条线程以相同的顺序请求加锁。
 * 				使用定是锁，Lock.tryLock(  ,  ),超时将自动解开死锁。
 * 				死锁检测，依靠算法实现，针对以上方式不能实现按序加锁和定时加锁的场景。			
 * 	
 *
 */
